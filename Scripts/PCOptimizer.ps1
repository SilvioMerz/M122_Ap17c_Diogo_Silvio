########################################################################
# Code Generated By: SAPIEN Technologies PrimalForms (Community Edition) v1.0.10.0
# Generated On: 27.03.2020 15:28
# Generated By: Diogo Caraça
########################################################################

#region Import the Assemblies
[reflection.assembly]::loadwithpartialname("System.Drawing") | Out-Null
[reflection.assembly]::loadwithpartialname("System.Windows.Forms") | Out-Null
#endregion

function GenerateForm {

$InitialFormWindowState = New-Object System.Windows.Forms.FormWindowState

$OnLoadForm_StateCorrection=
{#Correct the initial state of the form to prevent the .Net maximized form issue
    $formular.WindowState = $InitialFormWindowState
}


#Benachrichtugungsbox falls keine Elemente ausgewählt wurden im Formular
$messageBoxEmpty = {
    #Führt den gegebenen Skript-Code durch
    Invoke-Command -ScriptBlock {
        #Zeigt eine Messagebox
        [System.Windows.MessageBox]::Show('Nichts gewählt','PC Optimizer','OK','Warning')
    }
}


##################################################
#Wenn der Button "Leeren" gedrückt wird:
##################################################
$emptyDirectives= 
{
    #Es wird überprüft, ob alle Checkboxes nicht gewählt wurden
    if (!$music.Checked -and !$video.Checked -and !$downloads.Checked -and !$paperBin.Checked) {
        #Benachrichtugungsbox von Zeile 23
        & $messageBoxEmpty
    } else {
        #Wenn mindestens eine Box gewählt wurde, passiert folgendes:
        #Messagebox wird gerufen, Bestätigung der Aktion wird gefordert
        $msgBoxInput =  [System.Windows.MessageBox]::Show('Ordner leeren?','PC Optimizer','YesNo','Question')

        switch  ($msgBoxInput) {
            
            #Wenn der Benutzer 'Yes' drückt:
            'Yes' {
                $checkedfolders = @()
                #Nimmt den Pfad des Musik Ordners
                if ($music.Checked) {
                    $checkedfolders += "$env:USERPROFILE\Music"
                }
                #Nimmt den Pfad des Video Ordners
                if ($video.Checked) {
                    $checkedfolders += "$env:USERPROFILE\Videos"
                }
                #Nimmt den Pfad des Download Ordners
                if ($downloads.Checked) {
                    $checkedfolders += "$env:USERPROFILE\Downloads"
                }
                #Nimmt den Pfad des Papierkorbs
                if ($paperBin.Checked) {
                    $sid = ([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value
                    $checkedfolders += "C:\`$Recycle.Bin\$sid"
                }

                #Eine Iteration holt jedes einzelne Objekt der ausgewählten Ordner
                Get-ChildItem -Path $checkedfolders -Recurse -Force |
                ForEach-Object {
                    try {
                        #Löscht das Objekt
                        $_ | Remove-Item -Force -ErrorAction Stop
                    } catch {
                        #Falls es benutzt wird, wird eine Warnung geschrieben
                        Write-Warning "Could not remove Item $($_.TargetObject)"
                    }
                }

                #Messagebox wird gerufen, Ausführung der Aktion wird bestätigt
                $msgBoxInput =  [System.Windows.MessageBox]::Show('Die ausgewählten Ordner wurden erfolgreich geleert','PC Optimizer')
            }
            #Wenn der Benutzer 'No' drückt, passiert nichts & die Messagebox geht zu
        }
    }
}
##################################################


##################################################
#Wenn der Button 'Temporäre Dateien löschen' gedrückt wird:
##################################################
$deleteTempFiles= 
{
    #Messagebox wird gerufen, Bestätigung der Aktion wird gefordert
    $msgBoxInput =  [System.Windows.MessageBox]::Show('Temporäre Dateien löschen?','PC Optimizer','YesNo','Question')

    switch  ($msgBoxInput) {

        #Wenn der Benutzer 'Yes' drückt:
        'Yes' {
            #Array mit den Pfaden der Ordner, die temporäre Dateien enthalten
            $tempfolders = @(“C:\Windows\Temp\*”, “C:\Windows\Prefetch\*”, “C:\Users\*\Appdata\Local\Temp\*”)

            #Eine Iteration holt jedes einzelne Objekt der Temp-Ordner
            Get-ChildItem -Path $tempfolders -Recurse -Force |
            ForEach-Object {
                try {
                    #Löscht das Objekt
                    $_ | Remove-Item -Force -ErrorAction Stop
                } catch {
                    #Falls es benutzt wird, wird eine Warnung geschrieben
                    Write-Warning "Could not remove Item $($_.TargetObject)"
                }
            }
            #Messagebox wird gerufen, Ausführung der Aktion wird bestätigt
            $msgBoxInput =  [System.Windows.MessageBox]::Show('Die temporären Dateien wurden erfolgreich gelöscht','PC Optimizer')
        }
        #Wenn der Benutzer 'No' drückt, passiert nichts & die Messagebox geht zu
    }
}
##################################################


##################################################
#Wenn der Button "Deaktivieren" gedrückt wird:
##################################################
$deactivateApp= 
{
    #Es wird überprüft, ob eine App nicht gewählt wurde
    if ($listAutostart.SelectedIndices.Count -eq 0) {
        #Benachrichtugungsbox von Zeile 23
        & $messageBoxEmpty
    } else {

        # Name der gewählten App wird geholt
        $IdColumnIndex = $listAutostart.Columns[0].Index
        $appname = ($listAutostart.Items[$listAutostart.SelectedIndices[0]].SubItems[$IdColumnIndex]).Text

        # Appstart wird deaktiviert
        Invoke-Command -ScriptBlock {
            Set-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run -Name $appname -Value ([byte[]](0x33,0x32,0xFF))
        }
        
        #Messagebox wird gerufen, Ausführung der Aktion wird bestätigt
        $msgBoxInput =  [System.Windows.MessageBox]::Show('Die ausgewählte App wurde erfolgreich deaktiviert','PC Optimizer')
    }
}
##################################################


##################################################
#Wenn der Button "Aktivieren" gedrückt wird:
##################################################
$activateApp= 
{
    #Es wird überprüft, ob eine App nicht gewählt wurde
    if ($listAutostart.SelectedIndices.Count -eq 0) {
        #Benachrichtugungsbox von Zeile 23
        & $messageBoxEmpty
    } else {

        # Name der gewählten App wird geholt
        $IdColumnIndex = $listAutostart.Columns[0].Index
        $appname = ($listAutostart.Items[$listAutostart.SelectedIndices[0]].SubItems[$IdColumnIndex]).Text

        # Appstart wird aktiviert
        Invoke-Command -ScriptBlock {
            Set-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run -Name $appname -Value ([byte[]](0x02,00,00,00,00,00,00,00,00,00,00,00))
        }
                
        #Messagebox wird gerufen, Ausführung der Aktion wird bestätigt
        $msgBoxInput =  [System.Windows.MessageBox]::Show('Die ausgewählte App wurde erfolgreich aktiviert','PC Optimizer')
    }
}
##################################################


##################################################
#Wenn der Button "Aktualisieren" gedrückt wird:
#Leider konnte ich nicht in kurzer Zeit eine Real-Time Aktualisierung implementieren
##################################################
$updateProcesses= 
{
    #Listview leeren
    $listProcesses.Items.Clear()
    $listProcesses.Columns.Clear()

    #Prozesse holen
    $Processes = Get-Process | Select Id,ProcessName | Sort-Object CPU
    $ProcessProperties = $Processes[0].psObject.Properties

    #ListView Columheader erstellen
    $ProcessProperties | ForEach-Object {
        $listProcesses.Columns.Add("$($_.Name)") | Out-Null
    }
    #Prozesse anzeigen
    ForEach ($Process in $Processes){
 
        $ProcessListViewItem = New-Object System.Windows.Forms.ListViewItem($Process.Id)
 
        $Process.psObject.Properties | Where {$_.Name -ne "Id"} | ForEach-Object {
            $ColumnName = $_.Name
            $ProcessListViewItem.SubItems.Add("$($Process.$ColumnName)") | Out-Null
        }
        $listProcesses.Items.Add($ProcessListViewItem) | Out-Null
 
    }

    #Listview Spaltenbreiten angeben
    $listProcesses.Columns[0].Width = 40
    $listProcesses.Columns[1].Width = 174
}
##################################################


##################################################
#Wenn der Button "Beenden" gedrückt wird:
##################################################
$quitProcess= 
{
Write-Host $listProcesses.SelectedIndices[0]
Write-Host $listProcesses.SelectedIndices[0]
    #Es wird überprüft, ob Prozesse nicht gewählt wurden
    if ($listProcesses.SelectedIndices.Count -eq 0) {
        #Benachrichtugungsbox von Zeile 23
        & $messageBoxEmpty
    } else {

        # Array von gewählten Prozessen holen
        $SelectedProcesses = @($listProcesses.SelectedIndices)
 
        #Ids der Prozesse holen um genau diesen gewählten Prozess zu beenden
        $IdColumnIndex = ($listProcesses.Columns | Where {$_.Text -eq "Id"}).Index
   
        #Jeden einzelnen gewählten Prozess beenden
        $SelectedProcesses | ForEach-Object {
   
            # ...contains the Id of the process that is currently being "foreach'd",
            $ProcessId = ($listProcesses.Items[$_].SubItems[$IdColumnIndex]).Text
           
            # ...and stop it.
            Stop-Process -Id $ProcessId -Confirm:$false -Force
 
        }
        
        # Damit die Änderung ersichtlich ist in der Listview, erzeugt man hier ein Delay
        Start-Sleep -s 0.55
 
        # Listview aktualisieren nach dem Beenden
        &$updateProcesses
                
        #Messagebox wird gerufen, Ausführung der Aktion wird bestätigt
        $msgBoxInput =  [System.Windows.MessageBox]::Show('Die ausgewählten Prozesse wurden erfolgreich beendet','PC Optimizer')
    }
}
##################################################


#Formular erstellen
$formular = New-Object System.Windows.Forms.Form
    $formular.ClientSize = New-Object System.Drawing.Size(400,555)
    $formular.ShowIcon = $False
    $formular.Text = "PC Optimizer"
    $formular.FormBorderStyle = 'FixedDialog'
    $formular.MaximizeBox = $False
    $formular.MinimizeBox = $False


# Label "Speicheroptimierung" hinzufügen
$storageOptimization = New-Object System.Windows.Forms.Label
    $storageOptimization.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",30,1,2,1)
    $storageOptimization.Location = New-Object System.Drawing.Size(15,15)
    $storageOptimization.Size = New-Object System.Drawing.Size(370,40)
    $storageOptimization.Text = "Speicheroptimierung"

    $formular.Controls.Add($storageOptimization)

# Checkbox "Papierkorb" hinzufügen
$paperBin = New-Object System.Windows.Forms.CheckBox
    $paperBin.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $paperBin.Location = New-Object System.Drawing.Size(50,65)
    $paperBin.Size = New-Object System.Drawing.Size(150,20)
    $paperBin.Text = "Papierkorb"

    $formular.Controls.Add($paperBin)

# Checkbox "Musik Ordner" hinzufügen
$music = New-Object System.Windows.Forms.CheckBox
    $music.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $music.Location = New-Object System.Drawing.Size(200,65)
    $music.Size = New-Object System.Drawing.Size(150,20)
    $music.Text = "Musik Ordner"

    $formular.Controls.Add($music)

# Checkbox "Downloads" hinzufügen
$downloads = New-Object System.Windows.Forms.CheckBox
    $downloads.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $downloads.Location = New-Object System.Drawing.Size(50,95)
    $downloads.Size = New-Object System.Drawing.Size(150,20)
    $downloads.Text = "Downloads"
    
    $formular.Controls.Add($downloads)

# Checkbox "Video Ordner" hinzufügen
$video = New-Object System.Windows.Forms.CheckBox
    $video.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $video.Location = New-Object System.Drawing.Size(200,95)
    $video.Size = New-Object System.Drawing.Size(150,20)
    $video.Text = "Video Ordner"

    $formular.Controls.Add($video)

# Button "Leeren" hinzufügen
$emptyBtn = New-Object System.Windows.Forms.Button
    $emptyBtn.Location = New-Object System.Drawing.Size(20,125)
    $emptyBtn.Size = New-Object System.Drawing.Size(360,30)
    $emptyBtn.Text = "Leeren"
    $emptyBtn.add_Click($emptyDirectives)
    
    $formular.Controls.Add($emptyBtn)


# Label "Speicheroptimierung" hinzufügen
$performanceOptimization = New-Object System.Windows.Forms.Label
    $performanceOptimization.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",30,1,2,1)
    $performanceOptimization.Location = New-Object System.Drawing.Size(15,175)
    $performanceOptimization.Size = New-Object System.Drawing.Size(370,40)
    $performanceOptimization.Text = "Leistungsoptimierung"
    
    $formular.Controls.Add($performanceOptimization)

# Button "Temporäre Dateien löschen" hinzufügen
$emptyTmpBtn = New-Object System.Windows.Forms.Button
    $emptyTmpBtn.Location = New-Object System.Drawing.Size(20,225)
    $emptyTmpBtn.Size = New-Object System.Drawing.Size(360,30)
    $emptyTmpBtn.Text = "Temporäre Dateien löschen"
    $emptyTmpBtn.add_Click($deleteTempFiles)
    
    $formular.Controls.Add($emptyTmpBtn)

# Label "Autostart" hinzufügen
$autostart = New-Object System.Windows.Forms.Label
    $autostart.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $autostart.Location = New-Object System.Drawing.Size(20,265)
    $autostart.Size = New-Object System.Drawing.Size(360,20)
    $autostart.Text = "Autostart"
    
    $formular.Controls.Add($autostart)

# Listview für die Autostart-Apps hinzufügen
$listAutostart = New-Object System.Windows.Forms.ListView
    $listAutostart.Location = New-Object System.Drawing.Size(20,295)
    $listAutostart.Size = New-Object System.Drawing.Size(235,100)
    $listAutostart.UseCompatibleStateImageBehavior = $False
    $listAutostart.View = "Details"
    $listAutostart.MultiSelect = $False
    $listAutostart.Columns.Add("App") | Out-Null
    
    # Holt alle Autostart Applikationen des aktuellen Users
    $sid = ([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value
    Get-CimInstance Win32_StartupCommand | Where {$_.Location -eq "HKU\$sid\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"} | Select-Object Name | ForEach-Object {
        #$appListViewItem = New-Object System.Windows.Forms.ListViewItem($_.Name)
        $listAutostart.Items.Add($_.Name) | Out-Null
    }
    
    $formular.Controls.Add($listAutostart)

# Button "Deaktivieren" hinzufügen
$deactivateBtn = New-Object System.Windows.Forms.Button
    $deactivateBtn.Location = New-Object System.Drawing.Size(265,310)
    $deactivateBtn.Size = New-Object System.Drawing.Size(115,30)
    $deactivateBtn.Text = "Deaktivieren"
    $deactivateBtn.add_Click($deactivateApp)
    
    $formular.Controls.Add($deactivateBtn)

# Button "Aktivieren" hinzufügen
$activateBtn = New-Object System.Windows.Forms.Button
    $activateBtn.Location = New-Object System.Drawing.Size(265,350)
    $activateBtn.Size = New-Object System.Drawing.Size(115,30)
    $activateBtn.Text = "Aktivieren"
    $activateBtn.add_Click($activateApp)
    
    $formular.Controls.Add($activateBtn)

# Label "Prozesse" hinzufügen
$processes = New-Object System.Windows.Forms.Label
    $processes.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $processes.Location = New-Object System.Drawing.Size(20,405)
    $processes.Size = New-Object System.Drawing.Size(360,20)
    $processes.Text = "Prozesse"
    
    $formular.Controls.Add($processes)

# Listview für die laufende Prozesse hinzufügen
$listProcesses = New-Object System.Windows.Forms.ListView
    $listProcesses.Location = New-Object System.Drawing.Size(20,435)
    $listProcesses.Size = New-Object System.Drawing.Size(235,100)
    $listProcesses.UseCompatibleStateImageBehavior = $False
    $listProcesses.View = "Details"
    $listProcesses.MultiSelect = $True
    $listProcesses.FullRowSelect = $true
    $listProcesses.GridLines = $true
    
    $formular.Controls.Add($listProcesses)

# Button "Aktualisieren" hinzufügen
$updateBtn = New-Object System.Windows.Forms.Button
    $updateBtn.Location = New-Object System.Drawing.Size(265,450)
    $updateBtn.Size = New-Object System.Drawing.Size(115,30)
    $updateBtn.Text = "Aktualisieren"
    $updateBtn.add_Click($updateProcesses)
    
    $formular.Controls.Add($updateBtn)

# Button "Beenden" hinzufügen
$quitBtn = New-Object System.Windows.Forms.Button
    $quitBtn.Location = New-Object System.Drawing.Size(265,490)
    $quitBtn.Size = New-Object System.Drawing.Size(115,30)
    $quitBtn.Text = "Beenden"
    $quitBtn.add_Click($quitProcess)
    
    $formular.Controls.Add($quitBtn)

#Save the initial state of the form
$InitialFormWindowState = $formular.WindowState
#Init the OnLoad event to correct the initial state of the form
$formular.add_Load($OnLoadForm_StateCorrection)
#Show the Form
$formular.ShowDialog()| Out-Null

}

# Login Formular erstellen
$loginF = New-Object System.Windows.Forms.Form
    $loginF.ClientSize = New-Object System.Drawing.Size(380,60)
    $loginF.ShowIcon = $False
    $loginF.Text = "PC Optimizer"
    $loginF.FormBorderStyle = 'FixedDialog'
    $loginF.MaximizeBox = $False
    $loginF.MinimizeBox = $False

# Label "Passwort" hinzufügen
$passwortLbl = New-Object System.Windows.Forms.Label
    $passwortLbl.Font = New-Object System.Drawing.Font("Microsoft Sans Serif",15,0,2,1)
    $passwortLbl.Location = New-Object System.Drawing.Size(20,20)
    $passwortLbl.Size = New-Object System.Drawing.Size(80,20)
    $passwortLbl.Text = "Passwort"
    
    $loginF.Controls.Add($passwortLbl)

# Input Feld für das Passwort hinzufügen
$passwortInput = New-Object System.Windows.Forms.MaskedTextBox
    $passwortInput.Location = New-Object System.Drawing.Size(100,20)
    $passwortInput.Size = New-Object System.Drawing.Size(200,20)
    $passwortInput.PasswordChar = '*'

    $loginF.Controls.Add($passwortInput)

# Button "Beenden" hinzufügen
$loginBtn = New-Object System.Windows.Forms.Button
    $loginBtn.Location = New-Object System.Drawing.Size(320,20)
    $loginBtn.Size = New-Object System.Drawing.Size(50,20)
    $loginBtn.Text = "Login"
    $loginBtn.add_Click({
        if ($passwortInput.Text -ceq "TBZ") {
        
            # Login Form schliessen / verstecken
            $loginF.Hide()
            $loginF.Close() | Out-Null

            #PC Optimizer wird gezeigt
            GenerateForm
        } else {
            [System.Windows.MessageBox]::Show('Passwort ist falsch!','PC Optimizer','OK','Warning')
        }
    })
    
    $loginF.Controls.Add($loginBtn)
    
    #Um mit Enter das Formular abzuschicken
    $loginF.AcceptButton = $loginBtn

# Login Form anzeigen
$loginf.ShowDialog()
